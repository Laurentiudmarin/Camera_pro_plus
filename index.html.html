<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roof Calculator Pro - MÄƒsurare AR AvansatÄƒ</title>
    
    <!-- Biblioteci pentru AR È™i procesare -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        /* Layout principal cu trei coloane */
        .main-layout {
            display: grid;
            grid-template-columns: 400px 1fr 350px;
            gap: 20px;
            align-items: start;
        }

        /* Panoul camerei AR */
        .ar-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .panel-title {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            font-size: 1.3em;
            font-weight: bold;
            color: #2c3e50;
        }

        .camera-container {
            position: relative;
            width: 100%;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        #ar-video {
            width: 100%;
            height: 250px;
            object-fit: cover;
        }

        .ar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        #ar-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Controale AR */
        .ar-controls {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .control-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .control-btn.primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .control-btn.success {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
        }

        .control-btn.warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
        }

        .control-btn.danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .control-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .control-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Panoul central pentru fotografia mÄƒsuratÄƒ */
        .photo-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .photo-container {
            position: relative;
            width: 100%;
            min-height: 500px;
            border: 2px dashed #bdc3c7;
            border-radius: 10px;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #captured-photo {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 8px;
        }

        #measurement-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .photo-placeholder {
            text-align: center;
            color: #6c757d;
            font-size: 1.1em;
        }

        /* Controale foto */
        .photo-controls {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        /* Panoul proiectelor */
        .project-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        /* Lista punctelor */
        .points-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            background: #f8f9fa;
        }

        .point-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid #e9ecef;
            font-size: 14px;
        }

        .point-item:last-child {
            border-bottom: none;
        }

        .point-label {
            font-weight: bold;
            color: #2c3e50;
        }

        .point-coords {
            font-size: 12px;
            color: #6c757d;
        }

        /* Lista mÄƒsurÄƒtorilor */
        .measurements-list {
            margin-top: 15px;
        }

        .measurement-item {
            background: #e8f5e8;
            border: 1px solid #c3e6cb;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .measurement-label {
            font-weight: bold;
            color: #155724;
        }

        .measurement-value {
            color: #155724;
            font-family: monospace;
        }

        /* Lista proiectelor */
        .projects-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .project-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .project-item:hover {
            background: #e9ecef;
            transform: translateY(-1px);
        }

        .project-item.active {
            background: #d1ecf1;
            border-color: #bee5eb;
        }

        .project-name {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .project-info {
            font-size: 12px;
            color: #6c757d;
        }

        /* Status È™i calibrare */
        .status-panel {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .status-title {
            font-weight: bold;
            color: #495057;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-info {
            font-size: 14px;
            line-height: 1.5;
        }

        .calibration-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            font-size: 13px;
        }

        /* Dialog pentru salvarea proiectului */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 20px;
            border-radius: 10px;
            width: 400px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #2c3e50;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #6c757d;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #495057;
        }

        .form-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
        }

        .form-textarea {
            width: 100%;
            height: 80px;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
            resize: vertical;
        }

        /* InstrucÈ›iuni */
        .instructions {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .instructions h4 {
            color: #856404;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .instructions ul {
            color: #856404;
            margin-left: 20px;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        /* Responsive design */
        @media (max-width: 1200px) {
            .main-layout {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }

        /* AnimaÈ›ii */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .measuring {
            animation: pulse 1s infinite;
        }

        /* Loading indicator */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Butoane pentru puncte */
        .point-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #e74c3c;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .point-label-text {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: #2c3e50;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            white-space: nowrap;
        }

        /* Liniile de mÄƒsurare */
        .measurement-line {
            stroke: #e74c3c;
            stroke-width: 2;
            fill: none;
        }

        .measurement-text {
            fill: #2c3e50;
            font-size: 12px;
            font-weight: bold;
            text-anchor: middle;
        }

        .measurement-bg {
            fill: rgba(255, 255, 255, 0.9);
            stroke: #2c3e50;
            stroke-width: 1;
        }

        /* Toast pentru notificÄƒri */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            z-index: 1001;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.success {
            background: linear-gradient(135deg, #27ae60, #229954);
        }

        .toast.error {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .toast.info {
            background: linear-gradient(135deg, #3498db, #2980b9);
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>ğŸ—ï¸ Roof Calculator Pro AR</h1>
            <p>MÄƒsurare avansatÄƒ cu realitate augmentatÄƒ pentru acoperiÈ™uri</p>
        </header>

        <div class="instructions">
            <h4>ğŸ“‹ InstrucÈ›iuni de utilizare AR (DOAR Camera din Spate):</h4>
            <ul>
                <li><strong>ğŸš« IMPORTANT:</strong> AplicaÈ›ia foloseÈ™te <strong>EXCLUSIV CAMERA DIN SPATE</strong> pentru mÄƒsurÄƒtori tehnice precise</li>
                <li><strong>ğŸ“± Compatibilitate:</strong> NecesitÄƒ telefon/tabletÄƒ cu camerÄƒ din spate + HTTPS/localhost</li>
                <li><strong>ğŸ§ª Testare:</strong> FolosiÈ›i <strong>"ğŸ“± Test CamerÄƒ SPATE"</strong> pentru verificarea disponibilitÄƒÈ›ii</li>
                <li><strong>ğŸ“¹ Pornire AR:</strong> "PorneÈ™te AR" va cÄƒuta È™i conecta automat camera din spate</li>
                <li><strong>ğŸ¯ Calibrare:</strong> PlasaÈ›i obiect de referinÈ›Äƒ (monedÄƒ 1EUR/RON, card bancar) È™i calibraÈ›i</li>
                <li><strong>ğŸ“¸ Fotografiere:</strong> ÈšineÈ›i telefonul stabil È™i Ã®ndreptaÈ›i camera spre suprafaÈ›a de mÄƒsurat</li>
                <li><strong>ğŸ“ MÄƒsurare:</strong> AdÄƒugaÈ›i puncte pe fotografie pentru linii cu dimensiuni calculate automat</li>
                <li><strong>ğŸ’¾ Salvare:</strong> SalvaÈ›i proiectul pentru acces ulterior È™i export profesional</li>
            </ul>
            
            <div style="background: #ffeaa7; padding: 10px; border-radius: 6px; margin-top: 10px;">
                <strong>âš ï¸ Camera de selfie NU va fi folositÄƒ!</strong> Pentru mÄƒsurÄƒtori de acoperiÈ™uri la distanÈ›Äƒ (1-50m), 
                doar camera din spate oferÄƒ precizia necesarÄƒ. Dispozitivele fÄƒrÄƒ camerÄƒ din spate nu pot folosi aceastÄƒ aplicaÈ›ie.
            </div>
        </div>

        <div class="main-layout">
            <!-- Panoul AR Camera -->
            <div class="ar-panel">
                <div class="panel-title">
                    ğŸ“± Camera AR pentru MÄƒsurare
                </div>
                
                <div class="camera-container">
                    <video id="ar-video" autoplay muted playsinline></video>
                    <div class="ar-overlay">
                        <canvas id="ar-canvas"></canvas>
                    </div>
                </div>

                <div class="ar-controls">
                    <button class="control-btn primary" id="start-ar">
                        ğŸ“¹ PorneÈ™te AR
                    </button>
                    <button class="control-btn warning" id="calibrate-ar" disabled>
                        ğŸ¯ CalibreazÄƒ AR
                    </button>
                    <button class="control-btn success" id="take-photo" disabled>
                        ğŸ“¸ FÄƒ Fotografia
                    </button>
                    <button class="control-btn danger" id="stop-ar" disabled>
                        â¹ï¸ OpreÈ™te AR
                    </button>
                    <button class="control-btn" id="test-camera" style="grid-column: 1 / 3;">
                        ğŸ“± Test CamerÄƒ SPATE
                    </button>
                    <button class="control-btn" id="camera-help" style="grid-column: 3 / 5;">
                        â“ Ajutor CamerÄƒ SPATE
                    </button>
                </div>

                <div class="status-panel">
                    <div class="status-title">
                        ğŸ“Š Status AR
                    </div>
                    <div class="status-info" id="ar-status">
                        Sistemul AR este gata. ApÄƒsaÈ›i "PorneÈ™te AR" pentru conectarea camerei din spate.
                    </div>
                    <div id="calibration-display" style="display: none;"></div>
                </div>
            </div>

            <!-- Panoul central pentru fotografia mÄƒsuratÄƒ -->
            <div class="photo-panel">
                <div class="panel-title">
                    ğŸ“· Fotografia pentru MÄƒsurare
                </div>
                
                <div class="photo-container" id="photo-container">
                    <div class="photo-placeholder">
                        <div style="font-size: 3em; margin-bottom: 10px;">ğŸ“·</div>
                        <p>FaceÈ›i o fotografie cu AR pentru a Ã®ncepe mÄƒsurarea</p>
                    </div>
                    <img id="captured-photo" style="display: none;">
                    <canvas id="measurement-canvas" style="display: none;"></canvas>
                    <svg id="measurement-svg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none;"></svg>
                </div>

                <div class="photo-controls">
                    <button class="control-btn primary" id="add-point-mode">
                        ğŸ“ AdaugÄƒ Punct
                    </button>
                    <button class="control-btn warning" id="undo-point" disabled>
                        â†¶ UNDO
                    </button>
                    <button class="control-btn success" id="close-shape" disabled>
                        ğŸ”— Ãnchide Forma
                    </button>
                    <button class="control-btn danger" id="clear-points">
                        ğŸ—‘ï¸ È˜terge Tot
                    </button>
                </div>

                <div class="measurements-list" id="measurements-list">
                    <h4>ğŸ“ MÄƒsurÄƒtori:</h4>
                    <div style="text-align: center; color: #6c757d; padding: 20px; font-style: italic;">
                        Nu existÄƒ mÄƒsurÄƒtori Ã®ncÄƒ
                    </div>
                </div>
            </div>

            <!-- Panoul proiectelor -->
            <div class="project-panel">
                <div class="panel-title">
                    ğŸ“ Proiecte Salvate
                </div>

                <div class="points-list" id="points-list">
                    <div style="text-align: center; color: #6c757d; padding: 20px; font-style: italic;">
                        Nu existÄƒ puncte adÄƒugate
                    </div>
                </div>

                <div style="margin: 15px 0;">
                    <button class="control-btn success" id="save-project" style="width: 100%;">
                        ğŸ’¾ SalveazÄƒ Proiect
                    </button>
                </div>

                <div class="projects-list" id="projects-list">
                    <div style="text-align: center; color: #6c757d; padding: 20px; font-style: italic;">
                        Nu existÄƒ proiecte salvate
                    </div>
                </div>

                <div style="margin-top: 15px;">
                    <button class="control-btn primary" id="export-pdf" style="width: 100%; margin-bottom: 10px;">
                        ğŸ“„ ExportÄƒ PDF
                    </button>
                    <button class="control-btn warning" id="export-json" style="width: 100%;">
                        ğŸ’¾ ExportÄƒ JSON
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal pentru salvarea proiectului -->
    <div id="save-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">ğŸ’¾ SalveazÄƒ Proiect</h3>
                <button class="close-btn" id="close-modal">&times;</button>
            </div>
            <div class="form-group">
                <label class="form-label">Numele proiectului:</label>
                <input type="text" class="form-input" id="project-name" placeholder="Ex: AcoperiÈ™ Casa PrincipalÄƒ">
            </div>
            <div class="form-group">
                <label class="form-label">Descriere (opÈ›ional):</label>
                <textarea class="form-textarea" id="project-description" placeholder="Detalii despre proiect..."></textarea>
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button class="control-btn" id="cancel-save">AnuleazÄƒ</button>
                <button class="control-btn success" id="confirm-save">SalveazÄƒ</button>
            </div>
        </div>
    </div>

    <!-- Toast pentru notificÄƒri -->
    <div id="toast" class="toast"></div>

    <script>
        // ğŸš€ ROOF CALCULATOR PRO AR - SISTEM AVANSAT DE MÄ‚SURARE CU REALITATE AUGMENTATÄ‚
        
        class RoofCalculatorProAR {
            constructor() {
                // Elemente DOM
                this.video = null;
                this.arCanvas = null;
                this.arCtx = null;
                this.measurementCanvas = null;
                this.measurementCtx = null;
                this.measurementSvg = null;
                this.capturedPhoto = null;
                
                // State pentru AR
                this.stream = null;
                this.isARActive = false;
                this.isCalibrated = false;
                this.pixelsPerMM = 1;
                this.referenceObject = null;
                this.deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
                this.cameraDistance = 1; // metri
                
                // State pentru mÄƒsurare
                this.points = [];
                this.measurements = [];
                this.isAddingPoints = false;
                this.nextPointLabel = 'A';
                this.photoData = null;
                
                // Proiecte
                this.projects = [];
                this.currentProject = null;
                
                this.init();
            }

            async init() {
                console.log('ğŸš€ IniÈ›ializare Roof Calculator Pro AR...');
                
                // Configurare elemente DOM
                this.setupDOMElements();
                
                // Verificare compatibilitate browser
                await this.checkBrowserCompatibility();
                
                // Event listeners
                this.setupEventListeners();
                
                // ÃncÄƒrcare proiecte salvate
                this.loadProjects();
                
                // Setup senzori device
                this.setupDeviceSensors();
                
                console.log('âœ… IniÈ›ializare completÄƒ AR!');
                this.updateARStatus('Sistem AR gata pentru utilizare!', 'success');
            }

            async checkBrowserCompatibility() {
                // **EXPLICAÈšIE DETALIATÄ‚:** VerificÄƒm toate API-urile necesare pentru AR
                console.log('ğŸ” Verificare compatibilitate browser...');
                
                const compatibility = {
                    getUserMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
                    deviceOrientation: !!window.DeviceOrientationEvent,
                    deviceMotion: !!window.DeviceMotionEvent,
                    canvas: !!document.createElement('canvas').getContext,
                    localStorage: !!window.localStorage
                };

                console.log('ğŸ“Š Compatibilitate browser:', compatibility);

                // AfiÈ™Äƒm informaÈ›iile Ã®n interfaÈ›Äƒ
                let statusMessage = 'ğŸ” Verificare sistem: ';
                let warnings = [];

                if (!compatibility.getUserMedia) {
                    warnings.push('âš ï¸ API camerÄƒ indisponibil');
                }
                
                if (!compatibility.deviceOrientation) {
                    warnings.push('âš ï¸ Senzori orientare indisponibili');
                }

                if (warnings.length > 0) {
                    statusMessage += warnings.join(', ');
                    this.updateARStatus(statusMessage, 'warning');
                } else {
                    statusMessage += 'Toate API-urile sunt disponibile âœ…';
                    this.updateARStatus(statusMessage, 'success');
                }

                // VerificÄƒm camerele disponibile
                if (compatibility.getUserMedia) {
                    await this.enumerateDevices();
                }

                return compatibility;
            }

            async enumerateDevices() {
                // **EXPLICAÈšIE:** ListÄƒm toate camerele disponibile pe dispozitiv
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    
                    console.log('ğŸ“¹ Camere disponibile:', videoDevices);
                    
                    if (videoDevices.length === 0) {
                        this.updateARStatus('âš ï¸ Nu s-au gÄƒsit camere disponibile', 'warning');
                    } else {
                        console.log(`âœ… ${videoDevices.length} camerÄƒ/camere gÄƒsite`);
                        
                        // AfiÈ™Äƒm informaÈ›ii despre camere Ã®n consol 
                        videoDevices.forEach((device, index) => {
                            console.log(`ğŸ“± Camera ${index + 1}: ${device.label || 'NecunoscutÄƒ'} (ID: ${device.deviceId})`);
                        });
                    }
                    
                    return videoDevices;
                } catch (error) {
                    console.error('âŒ Eroare la enumerarea dispozitivelor:', error);
                    return [];
                }
            }

            showBackCameraHelp() {
                // **EXPLICAÈšIE DETALIATÄ‚:** InstrucÈ›iuni specifice pentru camera din spate
                const helpModal = document.createElement('div');
                helpModal.className = 'modal';
                helpModal.style.display = 'block';
                helpModal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px;">
                        <div class="modal-header">
                            <h3 class="modal-title">ğŸ“± Ajutor Camera din Spate pentru AR</h3>
                            <button class="close-btn" onclick="this.closest('.modal').remove()">&times;</button>
                        </div>
                        <div style="padding: 20px;">
                            <div style="background: #ffeaa7; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                                <strong>âš ï¸ IMPORTANT:</strong> Pentru mÄƒsurÄƒtori AR tehnice precise, aplicaÈ›ia foloseÈ™te EXCLUSIV camera din spate. 
                                Camera de selfie NU este potrivitÄƒ pentru mÄƒsurÄƒtori la distanÈ›Äƒ È™i nu va fi folositÄƒ niciodatÄƒ.
                            </div>
                            
                            <h4>ğŸ”§ VerificÄƒri pentru Camera din Spate:</h4>
                            <ol style="margin-left: 20px; line-height: 1.8;">
                                <li><strong>VerificaÈ›i dispozitivul:</strong>
                                    <ul style="margin: 5px 0 10px 20px;">
                                        <li>ğŸ“± Telefonul/tableta TREBUIE sÄƒ aibÄƒ camerÄƒ din spate</li>
                                        <li>ğŸ’» Laptop-urile cu doar camerÄƒ web frontalÄƒ NU vor funcÈ›iona</li>
                                        <li>ğŸ–¥ï¸ Desktop-urile cu camerÄƒ USB externÄƒ pot funcÈ›iona</li>
                                    </ul>
                                </li>
                                
                                <li><strong>Permisiuni camera din spate:</strong>
                                    <ul style="margin: 5px 0 10px 20px;">
                                        <li>CÃ¢nd vi se cere permisiunea, aprobaÈ›i accesul la camerÄƒ</li>
                                        <li>AplicaÈ›ia va selecta automat camera din spate</li>
                                        <li>DacÄƒ browserul Ã®ntreabÄƒ care camerÄƒ, alegeÈ›i "Camera din spate"</li>
                                    </ul>
                                </li>
                                
                                <li><strong>SetÄƒri browser pentru camera din spate:</strong>
                                    <ul style="margin: 5px 0 10px 20px;">
                                        <li><strong>Chrome/Edge:</strong> ApÄƒsaÈ›i ğŸ”’ â†’ Camera â†’ Permite</li>
                                        <li><strong>Firefox:</strong> ApÄƒsaÈ›i âš™ï¸ â†’ Camera â†’ Permite</li>
                                        <li><strong>Safari:</strong> SetÄƒri â†’ ConfidenÈ›ialitate â†’ Camera</li>
                                    </ul>
                                </li>
                                
                                <li><strong>Probleme comune:</strong>
                                    <ul style="margin: 5px 0 10px 20px;">
                                        <li>ğŸ“± <em>"Doar camera din faÈ›Äƒ detectatÄƒ"</em> â†’ VerificaÈ›i cÄƒ dispozitivul are camerÄƒ din spate</li>
                                        <li>ğŸš« <em>"Camera ocupatÄƒ"</em> â†’ ÃnchideÈ›i alte aplicaÈ›ii care folosesc camera</li>
                                        <li>âš ï¸ <em>"ConstrÃ¢ngeri neÃ®ndeplinite"</em> â†’ Camera din spate nu suportÄƒ rezoluÈ›ia cerutÄƒ</li>
                                    </ul>
                                </li>
                            </ol>
                            
                            <div style="background: #d1ecf1; padding: 15px; border-radius: 8px; margin: 15px 0;">
                                <strong>ğŸ’¡ De ce camera din spate?</strong><br>
                                â€¢ <strong>RezoluÈ›ie superioarÄƒ</strong> pentru mÄƒsurÄƒtori precise<br>
                                â€¢ <strong>Focalizare la distanÈ›Äƒ</strong> pentru acoperiÈ™uri<br>
                                â€¢ <strong>Stabilizare opticÄƒ</strong> pentru imagini clare<br>
                                â€¢ <strong>Senzori avansaÈ›i</strong> pentru calculul distanÈ›ei<br>
                                â€¢ <strong>PoziÈ›ionare naturalÄƒ</strong> pentru mÄƒsurarea obiectelor
                            </div>
                            
                            <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                                <button class="control-btn primary" onclick="roofCalculator.testBackCamera()">
                                    ğŸ“± Test CamerÄƒ Spate
                                </button>
                                <button class="control-btn warning" onclick="roofCalculator.showDeviceInfo()">
                                    ğŸ” Info Camere
                                </button>
                                <button class="control-btn" onclick="this.closest('.modal').remove()">
                                    Ãnchide
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(helpModal);
            }

            async testBackCamera() {
                // **EXPLICAÈšIE:** FuncÈ›ie de testare specificÄƒ pentru camera din spate
                console.log('ğŸ“± Ãncepe testul camerei din spate...');
                this.updateARStatus('ğŸ“± Test camerÄƒ din spate Ã®n curs...', 'info');
                
                try {
                    // EnumerÄƒm dispozitivele pentru a identifica camera din spate
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    
                    console.log('ğŸ“¹ Camere disponibile pentru test:', videoDevices);
                    
                    if (videoDevices.length === 0) {
                        throw new Error('Nu s-au gÄƒsit camere pe acest dispozitiv');
                    }
                    
                    // CÄƒutÄƒm camera din spate
                    const backCamera = videoDevices.find(device => 
                        device.label.toLowerCase().includes('back') ||
                        device.label.toLowerCase().includes('rear') ||
                        device.label.toLowerCase().includes('environment')
                    );
                    
                    // TestÄƒm cu facingMode environment
                    const testConstraints = {
                        video: {
                            facingMode: { exact: 'environment' }
                        }
                    };
                    
                    console.log('ğŸ§ª Testez camera din spate cu constrÃ¢ngeri:', testConstraints);
                    
                    const testStream = await navigator.mediaDevices.getUserMedia(testConstraints);
                    
                    // VerificÄƒm setÄƒrile obÈ›inute
                    const videoTrack = testStream.getVideoTracks()[0];
                    const settings = videoTrack.getSettings();
                    
                    console.log('âœ… Test camerÄƒ din spate reuÈ™it!');
                    console.log('ğŸ“¹ SetÄƒri camerÄƒ din spate:', settings);
                    console.log('ğŸ¥ Track info:', {
                        label: videoTrack.label,
                        kind: videoTrack.kind,
                        enabled: videoTrack.enabled,
                        readyState: videoTrack.readyState
                    });
                    
                    // VerificÄƒm cÄƒ nu e camera din faÈ›Äƒ
                    if (settings.facingMode === 'user') {
                        testStream.getTracks().forEach(track => track.stop());
                        throw new Error('S-a obÈ›inut camera din faÈ›Äƒ Ã®n loc de cea din spate');
                    }
                    
                    // Oprim stream-ul de test
                    testStream.getTracks().forEach(track => track.stop());
                    
                    const successMessage = `âœ… Camera din spate funcÈ›ioneazÄƒ perfect! (${settings.width}x${settings.height}, ${settings.facingMode || 'environment'})`;
                    this.updateARStatus(successMessage, 'success');
                    this.showToast('Camera din spate este gata pentru AR!', 'success');
                    
                    // Ãnchidem modal-ul de ajutor dacÄƒ este deschis
                    const helpModal = document.querySelector('.modal');
                    if (helpModal) helpModal.remove();
                    
                } catch (error) {
                    console.error('âŒ Test camerÄƒ din spate eÈ™uat:', error);
                    
                    let errorDetail = '';
                    switch (error.name) {
                        case 'NotAllowedError':
                            errorDetail = 'Permisiunea pentru camera din spate a fost refuzatÄƒ';
                            break;
                        case 'NotFoundError':
                            errorDetail = 'Nu s-a gÄƒsit camera din spate pe acest dispozitiv';
                            break;
                        case 'NotSupportedError':
                            errorDetail = 'Camera din spate nu este suportatÄƒ Ã®n acest browser';
                            break;
                        case 'OverconstrainedError':
                            errorDetail = 'ConstrÃ¢ngerile pentru camera din spate nu pot fi Ã®ndeplinite';
                            break;
                        default:
                            errorDetail = error.message;
                    }
                    
                    this.updateARStatus(`âŒ Test camerÄƒ din spate eÈ™uat: ${errorDetail}`, 'error');
                    this.showToast('Camera din spate nu funcÈ›ioneazÄƒ!', 'error');
                    
                    // SugerÄƒm verificÄƒri suplimentare
                    console.log('ğŸ’¡ Sugestii pentru rezolvare:');
                    console.log('1. VerificaÈ›i cÄƒ dispozitivul are camerÄƒ din spate');
                    console.log('2. VerificaÈ›i permisiunile browserului');
                    console.log('3. ÃnchideÈ›i alte aplicaÈ›ii care folosesc camera');
                    console.log('4. ÃncercaÈ›i cu un alt browser');
                }
            }

            async showDeviceInfo() {
                // **EXPLICAÈšIE:** AfiÈ™Äƒm informaÈ›ii despre dispozitiv cu focus pe camere
                const info = {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    cookieEnabled: navigator.cookieEnabled,
                    onLine: navigator.onLine,
                    language: navigator.language,
                    hardwareConcurrency: navigator.hardwareConcurrency,
                    deviceMemory: navigator.deviceMemory || 'necunoscut',
                    connection: navigator.connection ? {
                        effectiveType: navigator.connection.effectiveType,
                        downlink: navigator.connection.downlink
                    } : 'necunoscut'
                };

                // ObÈ›inem informaÈ›ii despre camere
                let cameraInfo = 'Se Ã®ncarcÄƒ...';
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    
                    if (videoDevices.length === 0) {
                        cameraInfo = 'âŒ Nu s-au gÄƒsit camere';
                    } else {
                        cameraInfo = videoDevices.map((device, index) => {
                            const label = device.label || `Camera ${index + 1}`;
                            let type = 'â“ Necunoscut';
                            
                            if (label.toLowerCase().includes('back') || 
                                label.toLowerCase().includes('rear') || 
                                label.toLowerCase().includes('environment')) {
                                type = 'ğŸ“± Spate (Perfect pentru AR!)';
                            } else if (label.toLowerCase().includes('front') || 
                                      label.toLowerCase().includes('user') || 
                                      label.toLowerCase().includes('selfie')) {
                                type = 'ğŸ¤³ FaÈ›Äƒ (Nu se foloseÈ™te pentru AR)';
                            }
                            
                            return `${index + 1}. ${label}\n   Tip: ${type}\n   ID: ${device.deviceId.substring(0, 20)}...`;
                        }).join('\n\n');
                    }
                } catch (error) {
                    cameraInfo = `âŒ Eroare la detectarea camerelor: ${error.message}`;
                }

                console.log('ğŸ“± InformaÈ›ii dispozitiv:', info);
                console.log('ğŸ“¹ InformaÈ›ii camere:', cameraInfo);
                
                const infoModal = document.createElement('div');
                infoModal.className = 'modal';
                infoModal.style.display = 'block';
                infoModal.innerHTML = `
                    <div class="modal-content" style="max-width: 700px;">
                        <div class="modal-header">
                            <h3 class="modal-title">ğŸ“± InformaÈ›ii Dispozitiv È™i Camere</h3>
                            <button class="close-btn" onclick="this.closest('.modal').remove()">&times;</button>
                        </div>
                        <div style="padding: 20px;">
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 12px; white-space: pre-wrap; overflow-x: auto; margin-bottom: 15px;">
ğŸŒ Browser: ${navigator.userAgent.split(' ').slice(-2).join(' ')}
ğŸ’» Platform: ${info.platform}
ğŸŒ LimbÄƒ: ${info.language}
ğŸ”— Online: ${info.onLine ? 'âœ…' : 'âŒ'}
ğŸª Cookies: ${info.cookieEnabled ? 'âœ…' : 'âŒ'}
âš¡ CPU Cores: ${info.hardwareConcurrency || 'necunoscut'}
ğŸ’¾ RAM: ${info.deviceMemory ? info.deviceMemory + 'GB' : 'necunoscut'}
ğŸ“¡ Conexiune: ${typeof info.connection === 'object' ? info.connection.effectiveType : 'necunoscut'}

ğŸ” Context securizat: ${window.isSecureContext ? 'âœ… HTTPS/localhost' : 'âŒ HTTP'}
ğŸ“ LocaÈ›ie: ${location.protocol}//${location.host}
                            </div>
                            
                            <div style="background: #e8f5e8; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 12px; white-space: pre-wrap; overflow-x: auto;">
ğŸ“¹ CAMERE DETECTATE:

${cameraInfo}

ğŸ’¡ PENTRU AR TEHNIC:
â€¢ AplicaÈ›ia foloseÈ™te EXCLUSIV camera din spate
â€¢ Camera din faÈ›Äƒ NU va fi folositÄƒ niciodatÄƒ
â€¢ Pentru mÄƒsurÄƒtori precise la distanÈ›Äƒ (1-50m)
â€¢ NecesitÄƒ dispozitiv cu camerÄƒ din spate de calitate
                            </div>
                            
                            <div style="text-align: center; margin-top: 20px;">
                                <button class="control-btn primary" onclick="roofCalculator.testBackCamera()" style="margin-right: 10px;">
                                    ğŸ“± Test CamerÄƒ Spate
                                </button>
                                <button class="control-btn" onclick="this.closest('.modal').remove()">
                                    Ãnchide
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(infoModal);
            }

            setupDOMElements() {
                this.video = document.getElementById('ar-video');
                this.arCanvas = document.getElementById('ar-canvas');
                this.arCtx = this.arCanvas.getContext('2d');
                this.measurementCanvas = document.getElementById('measurement-canvas');
                this.measurementCtx = this.measurementCanvas.getContext('2d');
                this.measurementSvg = document.getElementById('measurement-svg');
                this.capturedPhoto = document.getElementById('captured-photo');
            }

            setupEventListeners() {
                // Butoane AR
                document.getElementById('start-ar').addEventListener('click', () => this.startAR());
                document.getElementById('stop-ar').addEventListener('click', () => this.stopAR());
                document.getElementById('calibrate-ar').addEventListener('click', () => this.calibrateAR());
                document.getElementById('take-photo').addEventListener('click', () => this.takePhoto());
                document.getElementById('test-camera').addEventListener('click', () => this.testBackCamera());
                document.getElementById('camera-help').addEventListener('click', () => this.showBackCameraHelp());
                
                // Butoane mÄƒsurare
                document.getElementById('add-point-mode').addEventListener('click', () => this.togglePointMode());
                document.getElementById('undo-point').addEventListener('click', () => this.undoLastPoint());
                document.getElementById('close-shape').addEventListener('click', () => this.closeShape());
                document.getElementById('clear-points').addEventListener('click', () => this.clearAllPoints());
                
                // Butoane proiect
                document.getElementById('save-project').addEventListener('click', () => this.showSaveModal());
                document.getElementById('export-pdf').addEventListener('click', () => this.exportToPDF());
                document.getElementById('export-json').addEventListener('click', () => this.exportToJSON());
                
                // Modal events
                document.getElementById('close-modal').addEventListener('click', () => this.hideSaveModal());
                document.getElementById('cancel-save').addEventListener('click', () => this.hideSaveModal());
                document.getElementById('confirm-save').addEventListener('click', () => this.saveProject());
                
                // Click pe fotografie pentru adÄƒugarea punctelor
                document.getElementById('photo-container').addEventListener('click', (e) => this.handlePhotoClick(e));
                
                // Redimensionare
                window.addEventListener('resize', () => this.resizeCanvases());
                this.video.addEventListener('loadedmetadata', () => this.resizeCanvases());
            }

            setupDeviceSensors() {
                // **EXPLICAÈšIE DETALIATÄ‚:** AceastÄƒ funcÈ›ie configureazÄƒ senzorii telefonului pentru mÄƒsurarea AR
                // Folosim giroscopul È™i accelerometrul pentru a detecta orientarea È™i distanÈ›a
                
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', (e) => {
                        // **EXPLICAÈšIE:** CaptÄƒm valorile de orientare ale telefonului
                        // alpha = rotaÈ›ia Ã®n jurul axei Z (compas)
                        // beta = rotaÈ›ia Ã®n jurul axei X (Ã®nclinarea Ã®nainte/Ã®napoi)  
                        // gamma = rotaÈ›ia Ã®n jurul axei Y (Ã®nclinarea stÃ¢nga/dreapta)
                        this.deviceOrientation = {
                            alpha: e.alpha || 0,
                            beta: e.beta || 0,
                            gamma: e.gamma || 0
                        };
                        
                        // **EXPLICAÈšIE:** CalculÄƒm distanÈ›a aproximativÄƒ folosind Ã®nclinarea
                        // Cu cÃ¢t telefonul este mai Ã®nclinat, cu atÃ¢t obiectul este mai departe
                        this.calculateDistance();
                    });
                }

                if (window.DeviceMotionEvent) {
                    window.addEventListener('devicemotion', (e) => {
                        // **EXPLICAÈšIE:** Folosim accelerometrul pentru stabilitate
                        // DetectÄƒm cÃ¢nd telefonul este stabil pentru mÄƒsurÄƒtori precise
                        const acceleration = e.accelerationIncludingGravity;
                        if (acceleration) {
                            this.deviceAcceleration = {
                                x: acceleration.x || 0,
                                y: acceleration.y || 0,
                                z: acceleration.z || 0
                            };
                        }
                    });
                }
            }

            calculateDistance() {
                // **EXPLICAÈšIE DETALIATÄ‚:** AceastÄƒ funcÈ›ie calculeazÄƒ distanÈ›a pÃ¢nÄƒ la obiect
                // folosind Ã®nclinarea telefonului (beta) È™i Ã®nÄƒlÈ›imea estimatÄƒ de È›inere
                
                const beta = this.deviceOrientation.beta; // Ã®nclinarea Ã®nainte/Ã®napoi
                const assumedHeight = 1.5; // Ã®nÄƒlÈ›imea medie de È›inere a telefonului (metri)
                
                if (beta && beta > 10 && beta < 80) {
                    // **EXPLICAÈšIE:** Folosim trigonometria pentru calculul distanÈ›ei
                    // tg(unghi) = Ã®nÄƒlÈ›ime / distanÈ›Äƒ  =>  distanÈ›Äƒ = Ã®nÄƒlÈ›ime / tg(unghi)
                    const angleRad = (90 - beta) * Math.PI / 180;
                    this.cameraDistance = Math.abs(assumedHeight / Math.tan(angleRad));
                    
                    // LimiteazÄƒ distanÈ›a Ã®ntre 0.5m È™i 50m pentru mÄƒsurÄƒtori practice
                    this.cameraDistance = Math.max(0.5, Math.min(50, this.cameraDistance));
                } else {
                    // DistanÈ›Äƒ implicitÄƒ cÃ¢nd nu putem calcula precis
                    this.cameraDistance = 2;
                }
            }

            async startAR() {
                try {
                    this.updateARStatus('Verific camerele disponibile pe dispozitiv...', 'info');
                    
                    // **EXPLICAÈšIE DETALIATÄ‚:** VerificÄƒm mai Ã®ntÃ¢i dacÄƒ API-ul este disponibil
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('API-ul camerei nu este disponibil Ã®n acest browser');
                    }

                    // VerificÄƒm dacÄƒ suntem pe HTTPS sau localhost
                    const isSecureContext = window.isSecureContext || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
                    if (!isSecureContext) {
                        this.updateARStatus('âš ï¸ CamerÄƒ disponibilÄƒ doar pe HTTPS sau localhost', 'warning');
                    }

                    // **EXPLICAÈšIE CRITICÄ‚:** Pentru mÄƒsurÄƒtori AR tehnice, folosim EXCLUSIV camera din spate
                    // Camera din spate are rezoluÈ›ie mai bunÄƒ È™i este mai potrivitÄƒ pentru mÄƒsurÄƒri la distanÈ›Äƒ
                    
                    this.updateARStatus('CÄƒutare camerÄƒ din spate pentru mÄƒsurÄƒtori tehnice...', 'info');
                    
                    // VerificÄƒm camerele disponibile pentru a identifica camera din spate
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    
                    console.log('ğŸ“¹ Camere detectate:', videoDevices);
                    
                    // CÄƒutÄƒm especÃ­fic camera din spate
                    const backCamera = videoDevices.find(device => 
                        device.label.toLowerCase().includes('back') ||
                        device.label.toLowerCase().includes('rear') ||
                        device.label.toLowerCase().includes('environment') ||
                        device.label.toLowerCase().includes('0') // Adesea camera 0 este cea din spate
                    );
                    
                    if (backCamera) {
                        console.log('âœ… Camera din spate identificatÄƒ:', backCamera.label);
                        this.updateARStatus(`ğŸ“± Camera din spate detectatÄƒ: ${backCamera.label}`, 'success');
                    } else {
                        console.log('âš ï¸ Nu s-a putut identifica specific camera din spate, Ã®ncerc cu environment facingMode');
                    }

                    // **EXPLICAÈšIE:** ÃncercÄƒm mai multe strategii pentru camera din spate, NICIODATÄ‚ cea din faÈ›Äƒ
                    let constraints;
                    let attempts = [
                        // Ãncercarea 1: Camera specificatÄƒ prin deviceId (dacÄƒ am identificat-o)
                        backCamera ? {
                            video: {
                                deviceId: { exact: backCamera.deviceId },
                                width: { ideal: 1920, min: 1280 },
                                height: { ideal: 1080, min: 720 }
                            }
                        } : null,
                        
                        // Ãncercarea 2: Camera din spate prin facingMode cu rezoluÈ›ie HD
                        {
                            video: {
                                facingMode: { exact: 'environment' },
                                width: { ideal: 1920, min: 1280 },
                                height: { ideal: 1080, min: 720 }
                            }
                        },
                        
                        // Ãncercarea 3: Camera din spate cu facingMode ideal (nu exact)
                        {
                            video: {
                                facingMode: { ideal: 'environment' },
                                width: { ideal: 1280, min: 640 },
                                height: { ideal: 720, min: 480 }
                            }
                        },
                        
                        // Ãncercarea 4: Doar facingMode environment, orice rezoluÈ›ie
                        {
                            video: {
                                facingMode: 'environment'
                            }
                        }
                    ].filter(Boolean); // EliminÄƒm null-urile

                    let streamObtained = false;
                    let lastError = null;

                    // **EXPLICAÈšIE:** ÃncercÄƒm fiecare constrÃ¢ngere pentru camera din spate
                    for (let i = 0; i < attempts.length; i++) {
                        constraints = attempts[i];
                        console.log(`ğŸ” Ãncercarea ${i + 1} pentru camera din spate:`, constraints);
                        
                        try {
                            this.updateARStatus(`Ãncercarea ${i + 1}: Conectare la camera din spate...`, 'info');
                            this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                            
                            // VerificÄƒm cÄƒ am obÈ›inut Ã®ntr-adevÄƒr camera din spate
                            const videoTrack = this.stream.getVideoTracks()[0];
                            const settings = videoTrack.getSettings();
                            
                            console.log('ğŸ“¹ SetÄƒri camerÄƒ obÈ›inute:', settings);
                            
                            // **EXPLICAÈšIE CRITICÄ‚:** VerificÄƒm cÄƒ nu am primit accidental camera din faÈ›Äƒ
                            if (settings.facingMode === 'user') {
                                console.warn('âš ï¸ S-a obÈ›inut camera din faÈ›Äƒ Ã®n loc de cea din spate, opresc stream-ul...');
                                this.stream.getTracks().forEach(track => track.stop());
                                this.stream = null;
                                throw new Error('S-a obÈ›inut camera din faÈ›Äƒ Ã®n loc de cea din spate');
                            }
                            
                            streamObtained = true;
                            console.log(`âœ… Succes cu Ã®ncercarea ${i + 1}! Camera din spate conectatÄƒ.`);
                            break;
                            
                        } catch (error) {
                            console.warn(`âŒ Ãncercarea ${i + 1} eÈ™uatÄƒ:`, error.message);
                            lastError = error;
                            
                            if (this.stream) {
                                this.stream.getTracks().forEach(track => track.stop());
                                this.stream = null;
                            }
                        }
                    }

                    // **EXPLICAÈšIE:** DacÄƒ nu am reuÈ™it sÄƒ obÈ›inem camera din spate, NU folosim camera din faÈ›Äƒ
                    if (!streamObtained) {
                        console.error('âŒ Nu s-a putut obÈ›ine camera din spate pentru mÄƒsurÄƒtori AR');
                        
                        // VerificÄƒm dacÄƒ dispozitivul are doar camera din faÈ›Äƒ
                        const frontCamera = videoDevices.find(device => 
                            device.label.toLowerCase().includes('front') ||
                            device.label.toLowerCase().includes('user') ||
                            device.label.toLowerCase().includes('selfie')
                        );
                        
                        if (frontCamera && videoDevices.length === 1) {
                            throw new Error('Acest dispozitiv are doar camera din faÈ›Äƒ. Pentru mÄƒsurÄƒtori AR tehnice precise, este necesarÄƒ camera din spate.');
                        } else {
                            throw new Error(`Nu s-a putut accesa camera din spate. Ultima eroare: ${lastError?.message || 'necunoscutÄƒ'}`);
                        }
                    }

                    // **EXPLICAÈšIE:** ConfigurÄƒm video-ul È™i verificÄƒm cÄƒ totul funcÈ›ioneazÄƒ
                    console.log('âœ… Stream camerÄƒ din spate obÈ›inut:', this.stream);
                    const videoTrack = this.stream.getVideoTracks()[0];
                    const settings = videoTrack.getSettings();
                    console.log('ğŸ“¹ SetÄƒri finale camerÄƒ:', settings);
                    
                    this.video.srcObject = this.stream;
                    
                    // AÈ™teptÄƒm ca video-ul sÄƒ Ã®ncarce metadatele
                    await new Promise((resolve, reject) => {
                        this.video.onloadedmetadata = () => {
                            console.log('âœ… Video metadata Ã®ncÄƒrcat:', {
                                width: this.video.videoWidth,
                                height: this.video.videoHeight,
                                duration: this.video.duration
                            });
                            resolve();
                        };
                        
                        this.video.onerror = (e) => {
                            console.error('âŒ Eroare la Ã®ncÄƒrcarea video:', e);
                            reject(new Error('Eroare la Ã®ncÄƒrcarea video din camera din spate'));
                        };
                        
                        // Timeout dupÄƒ 15 secunde
                        setTimeout(() => {
                            reject(new Error('Timeout la Ã®ncÄƒrcarea video din camera din spate'));
                        }, 15000);
                    });

                    this.isARActive = true;
                    
                    // ActualizÄƒm interfaÈ›a
                    document.getElementById('start-ar').disabled = true;
                    document.getElementById('stop-ar').disabled = false;
                    document.getElementById('calibrate-ar').disabled = false;
                    
                    // Ãncepe loop-ul de detectare AR
                    this.startARLoop();
                    
                    // AfiÈ™Äƒm informaÈ›ii despre camera folositÄƒ
                    const finalSettings = videoTrack.getSettings();
                    const cameraInfo = `Camera din spate activÄƒ: ${finalSettings.width}x${finalSettings.height}`;
                    
                    this.updateARStatus(`âœ… ${cameraInfo} - Gata pentru calibrare!`, 'success');
                    this.showToast('Camera din spate conectatÄƒ pentru mÄƒsurÄƒtori AR!', 'success');
                    
                } catch (error) {
                    console.error('âŒ Eroare completÄƒ la pornirea AR:', error);
                    
                    let errorMessage = 'Eroare la activarea camerei din spate: ';
                    
                    if (error.name === 'NotAllowedError') {
                        errorMessage += 'Permisiunea pentru camerÄƒ a fost refuzatÄƒ. VÄƒ rugÄƒm sÄƒ permiteÈ›i accesul la camerÄƒ Ã®n setÄƒrile browserului.';
                    } else if (error.name === 'NotFoundError') {
                        errorMessage += 'Nu s-a gÄƒsit camera din spate pe acest dispozitiv. VerificaÈ›i cÄƒ dispozitivul are camerÄƒ din spate.';
                    } else if (error.name === 'NotSupportedError') {
                        errorMessage += 'Camera din spate nu este suportatÄƒ Ã®n acest browser.';
                    } else if (error.name === 'NotReadableError') {
                        errorMessage += 'Camera din spate este deja folositÄƒ de o altÄƒ aplicaÈ›ie.';
                    } else if (error.name === 'OverconstrainedError') {
                        errorMessage += 'ConstrÃ¢ngerile pentru camera din spate nu pot fi Ã®ndeplinite. ÃncercaÈ›i cu un alt dispozitiv.';
                    } else {
                        errorMessage += error.message;
                    }
                    
                    this.updateARStatus(errorMessage, 'error');
                    this.showToast('Nu s-a putut activa camera din spate!', 'error');
                    
                    // Oferim instrucÈ›iuni specifice pentru camera din spate
                    this.showBackCameraHelp();
                }
            }

            startARLoop() {
                // **EXPLICAÈšIE DETALIATÄ‚:** Acest loop continuÄƒ sÄƒ ruleze cÃ¢t timp AR-ul este activ
                // È™i actualizeazÄƒ canvas-ul cu informaÈ›ii de mÄƒsurare Ã®n timp real
                
                if (!this.isARActive) return;

                // RedimensioneazÄƒ canvas-ul sÄƒ se potriveascÄƒ cu video-ul
                this.resizeCanvases();
                
                // CurÄƒÈ›Äƒ canvas-ul
                this.arCtx.clearRect(0, 0, this.arCanvas.width, this.arCanvas.height);
                
                if (this.isCalibrated) {
                    // **EXPLICAÈšIE:** DesenÄƒm indicatori AR pe ecran
                    this.drawARIndicators();
                }
                
                // ContinuÄƒ loop-ul
                requestAnimationFrame(() => this.startARLoop());
            }

            drawARIndicators() {
                // **EXPLICAÈšIE DETALIATÄ‚:** DesenÄƒm indicatori vizuali pe camera AR
                // pentru a ajuta utilizatorul sÄƒ Ã®nÈ›eleagÄƒ ce se Ã®ntÃ¢mplÄƒ
                
                const centerX = this.arCanvas.width / 2;
                const centerY = this.arCanvas.height / 2;
                
                // DesenÄƒm crosshair-ul central
                this.arCtx.strokeStyle = '#27ae60';
                this.arCtx.lineWidth = 2;
                this.arCtx.beginPath();
                // Linie orizontalÄƒ
                this.arCtx.moveTo(centerX - 20, centerY);
                this.arCtx.lineTo(centerX + 20, centerY);
                // Linie verticalÄƒ
                this.arCtx.moveTo(centerX, centerY - 20);
                this.arCtx.lineTo(centerX, centerY + 20);
                this.arCtx.stroke();
                
                // AfiÈ™Äƒm informaÈ›ii despre calibrare È™i distanÈ›Äƒ
                this.arCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.arCtx.fillRect(10, 10, 200, 80);
                
                this.arCtx.fillStyle = '#27ae60';
                this.arCtx.font = 'bold 14px Arial';
                this.arCtx.fillText('âœ… AR Calibrat', 20, 30);
                this.arCtx.fillText(`ğŸ“ DistanÈ›Äƒ: ${this.cameraDistance.toFixed(1)}m`, 20, 50);
                this.arCtx.fillText(`ğŸ¯ Scala: ${this.pixelsPerMM.toFixed(2)} px/mm`, 20, 70);
            }

            async calibrateAR() {
                if (!this.isARActive) {
                    this.updateARStatus('PorniÈ›i camera AR mai Ã®ntÃ¢i!', 'error');
                    return;
                }

                this.updateARStatus('CÄƒutare obiect de referinÈ›Äƒ pentru calibrare...', 'info');
                
                // **EXPLICAÈšIE DETALIATÄ‚:** SimulÄƒm detectarea unui obiect de referinÈ›Äƒ
                // Ãn implementarea realÄƒ, aici am folosi algoritmi de computer vision
                // pentru a detecta monede, carduri bancare, pachete de È›igÄƒri etc.
                
                // SimulÄƒm timpul de procesare pentru detectare
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Lista de obiecte de referinÈ›Äƒ cu dimensiunile lor reale
                const referenceObjects = [
                    { type: 'MonedÄƒ 1 EUR', size: 23.25, unit: 'mm', confidence: 0.89 },
                    { type: 'MonedÄƒ 1 RON', size: 24.5, unit: 'mm', confidence: 0.92 },
                    { type: 'Card Bancar', size: 85.6, unit: 'mm', confidence: 0.85 },
                    { type: 'Pachet ÈšigÄƒri', size: 87, unit: 'mm', confidence: 0.78 }
                ];

                // SelectÄƒm un obiect detectat aleator pentru demonstraÈ›ie
                const detected = referenceObjects[Math.floor(Math.random() * referenceObjects.length)];
                
                this.isCalibrated = true;
                this.referenceObject = detected;
                
                // **EXPLICAÈšIE CRITICÄ‚:** Calculul pixeli per milimetru este fundamental
                // pentru toate mÄƒsurÄƒrile ulterioare. Aceasta este baza preciziei sistemului.
                // Presupunem cÄƒ obiectul ocupÄƒ aproximativ 100 de pixeli pe ecran
                const assumedPixelSize = 100;
                this.pixelsPerMM = assumedPixelSize / detected.size;
                
                // **EXPLICAÈšIE:** AjustÄƒm scala Ã®n funcÈ›ie de distanÈ›Äƒ pentru precizie
                // Cu cÃ¢t suntem mai departe, cu atÃ¢t pixelii reprezintÄƒ dimensiuni mai mari
                this.pixelsPerMM = this.pixelsPerMM * (2 / this.cameraDistance);

                // ActualizÄƒm interfaÈ›a cu informaÈ›iile de calibrare
                const confidencePercent = Math.round(detected.confidence * 100);
                const calibrationInfo = `
                    <div class="calibration-info">
                        <strong>âœ… ${detected.type}</strong><br>
                        ğŸ“ MÄƒrime: ${detected.size}${detected.unit}<br>
                        ğŸ¯ Ãncredere: ${confidencePercent}%<br>
                        ğŸ“ Scala: ${this.pixelsPerMM.toFixed(3)} px/mm<br>
                        ğŸ“ DistanÈ›Äƒ: ${this.cameraDistance.toFixed(1)}m
                    </div>
                `;
                
                document.getElementById('calibration-display').innerHTML = calibrationInfo;
                document.getElementById('calibration-display').style.display = 'block';
                document.getElementById('take-photo').disabled = false;
                
                this.updateARStatus(`Calibrare reuÈ™itÄƒ cu ${detected.type} (${confidencePercent}% Ã®ncredere)`, 'success');
            }

            async takePhoto() {
                if (!this.isCalibrated) {
                    this.updateARStatus('CalibraÈ›i AR-ul mai Ã®ntÃ¢i!', 'error');
                    return;
                }

                try {
                    // **EXPLICAÈšIE DETALIATÄ‚:** CapturÄƒm frame-ul curent din video ca fotografie
                    // AceastÄƒ fotografie va fi folositÄƒ pentru mÄƒsurÄƒtori
                    
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = this.video.videoWidth;
                    canvas.height = this.video.videoHeight;
                    
                    // DesenÄƒm frame-ul video pe canvas
                    ctx.drawImage(this.video, 0, 0);
                    
                    // Convertim la imagine
                    this.photoData = canvas.toDataURL('image/jpeg', 0.9);
                    
                    // **EXPLICAÈšIE:** AfiÈ™Äƒm fotografia Ã®n panoul central pentru mÄƒsurare
                    this.capturedPhoto.src = this.photoData;
                    this.capturedPhoto.style.display = 'block';
                    this.measurementCanvas.style.display = 'block';
                    this.measurementSvg.style.display = 'block';
                    
                    // Ascundem placeholder-ul
                    document.querySelector('.photo-placeholder').style.display = 'none';
                    
                    // ConfigurÄƒm canvas-ul pentru mÄƒsurare
                    this.setupMeasurementCanvas();
                    
                    this.updateARStatus('Fotografie capturatÄƒ! PuteÈ›i adÄƒuga puncte pentru mÄƒsurare.', 'success');
                    this.showToast('Fotografie salvatÄƒ cu succes!', 'success');
                    
                } catch (error) {
                    console.error('Eroare la capturarea fotografiei:', error);
                    this.updateARStatus('Eroare la capturarea fotografiei', 'error');
                }
            }

            setupMeasurementCanvas() {
                // **EXPLICAÈšIE DETALIATÄ‚:** ConfigurÄƒm canvas-ul pentru a permite mÄƒsurÄƒtori pe fotografie
                // Canvas-ul va avea aceeaÈ™i mÄƒrime ca fotografia afiÈ™atÄƒ
                
                const container = document.getElementById('photo-container');
                const rect = container.getBoundingClientRect();
                
                this.measurementCanvas.width = rect.width;
                this.measurementCanvas.height = rect.height;
                
                // ConfigurÄƒm SVG-ul pentru linii È™i text
                this.measurementSvg.setAttribute('width', rect.width);
                this.measurementSvg.setAttribute('height', rect.height);
                this.measurementSvg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);
            }

            togglePointMode() {
                // **EXPLICAÈšIE:** ActivÄƒm/dezactivÄƒm modul de adÄƒugare puncte
                this.isAddingPoints = !this.isAddingPoints;
                
                const btn = document.getElementById('add-point-mode');
                if (this.isAddingPoints) {
                    btn.textContent = 'ğŸ”´ DezactiveazÄƒ Puncte';
                    btn.classList.remove('primary');
                    btn.classList.add('danger');
                    this.showToast('Mod adÄƒugare puncte activat. Click pe fotografie pentru a adÄƒuga puncte.', 'info');
                } else {
                    btn.textContent = 'ğŸ“ AdaugÄƒ Punct';
                    btn.classList.remove('danger');
                    btn.classList.add('primary');
                    this.showToast('Mod adÄƒugare puncte dezactivat.', 'info');
                }
            }

            handlePhotoClick(e) {
                // **EXPLICAÈšIE DETALIATÄ‚:** GestionÄƒm click-urile pe fotografie pentru adÄƒugarea punctelor
                if (!this.isAddingPoints || !this.photoData) return;
                
                const rect = e.currentTarget.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // **EXPLICAÈšIE:** CreÄƒm un punct nou cu coordonatele È™i eticheta
                const point = {
                    x: x,
                    y: y,
                    label: this.nextPointLabel,
                    id: Date.now()
                };
                
                this.points.push(point);
                
                // **EXPLICAÈšIE:** CalculÄƒm urmÄƒtoarea etichetÄƒ (A, B, C, D...)
                this.nextPointLabel = String.fromCharCode(this.nextPointLabel.charCodeAt(0) + 1);
                
                // DesenÄƒm punctul pe fotografie
                this.drawPoint(point);
                
                // DacÄƒ avem cel puÈ›in 2 puncte, calculÄƒm mÄƒsurÄƒtoarea
                if (this.points.length >= 2) {
                    this.calculateMeasurement();
                }
                
                this.updatePointsList();
                this.updateControls();
                
                this.showToast(`Punct ${point.label} adÄƒugat`, 'success');
            }

            drawPoint(point) {
                // **EXPLICAÈšIE DETALIATÄ‚:** DesenÄƒm punctul vizual pe fotografie
                
                // CreÄƒm elementul HTML pentru punct
                const pointElement = document.createElement('div');
                pointElement.className = 'point-marker';
                pointElement.style.left = point.x + 'px';
                pointElement.style.top = point.y + 'px';
                pointElement.dataset.pointId = point.id;
                
                // AdÄƒugÄƒm eticheta punctului
                const labelElement = document.createElement('div');
                labelElement.className = 'point-label-text';
                labelElement.textContent = point.label;
                pointElement.appendChild(labelElement);
                
                // AdÄƒugÄƒm punctul Ã®n container
                document.getElementById('photo-container').appendChild(pointElement);
            }

            calculateMeasurement() {
                // **EXPLICAÈšIE DETALIATÄ‚:** CalculÄƒm distanÈ›a realÄƒ Ã®ntre ultimele douÄƒ puncte
                if (this.points.length < 2) return;
                
                const point1 = this.points[this.points.length - 2];
                const point2 = this.points[this.points.length - 1];
                
                // **EXPLICAÈšIE CRITICÄ‚:** Calculul distanÈ›ei Ã®n pixeli folosind teorema lui Pitagora
                const pixelDistance = Math.sqrt(
                    Math.pow(point2.x - point1.x, 2) + 
                    Math.pow(point2.y - point1.y, 2)
                );
                
                // **EXPLICAÈšIE CRITICÄ‚:** Convertim pixelii Ã®n milimetri folosind scala de calibrare
                // Apoi ajustÄƒm pentru distanÈ›a camerei (perspectiva)
                const mmDistance = pixelDistance / this.pixelsPerMM;
                const adjustedDistance = mmDistance * (this.cameraDistance / 2); // Ajustare pentru distanÈ›Äƒ
                
                // CreÄƒm mÄƒsurÄƒtoarea
                const measurement = {
                    id: Date.now(),
                    fromPoint: point1.label,
                    toPoint: point2.label,
                    label: `${point1.label}${point2.label}`,
                    pixelDistance: pixelDistance,
                    mmDistance: adjustedDistance,
                    mDistance: adjustedDistance / 1000,
                    point1: point1,
                    point2: point2
                };
                
                this.measurements.push(measurement);
                
                // DesenÄƒm linia de mÄƒsurare
                this.drawMeasurementLine(measurement);
                this.updateMeasurementsList();
            }

            drawMeasurementLine(measurement) {
                // **EXPLICAÈšIE DETALIATÄ‚:** DesenÄƒm linia de mÄƒsurare pe SVG
                // cu textul ce afiÈ™eazÄƒ dimensiunea
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', measurement.point1.x);
                line.setAttribute('y1', measurement.point1.y);
                line.setAttribute('x2', measurement.point2.x);
                line.setAttribute('y2', measurement.point2.y);
                line.setAttribute('class', 'measurement-line');
                line.dataset.measurementId = measurement.id;
                
                // CalculÄƒm poziÈ›ia textului la mijlocul liniei
                const midX = (measurement.point1.x + measurement.point2.x) / 2;
                const midY = (measurement.point1.y + measurement.point2.y) / 2;
                
                // CreÄƒm background pentru text
                const textBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                textBg.setAttribute('x', midX - 25);
                textBg.setAttribute('y', midY - 10);
                textBg.setAttribute('width', 50);
                textBg.setAttribute('height', 20);
                textBg.setAttribute('class', 'measurement-bg');
                
                // CreÄƒm textul cu mÄƒsurÄƒtoarea
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', midX);
                text.setAttribute('y', midY + 4);
                text.setAttribute('class', 'measurement-text');
                
                // **EXPLICAÈšIE:** FormatÄƒm textul Ã®n funcÈ›ie de mÄƒrime (mm, cm, m)
                let displayText;
                if (measurement.mDistance >= 1) {
                    displayText = `${measurement.mDistance.toFixed(2)}m`;
                } else if (measurement.mmDistance >= 10) {
                    displayText = `${(measurement.mmDistance / 10).toFixed(1)}cm`;
                } else {
                    displayText = `${measurement.mmDistance.toFixed(0)}mm`;
                }
                
                text.textContent = displayText;
                
                // AdÄƒugÄƒm elementele Ã®n SVG
                this.measurementSvg.appendChild(line);
                this.measurementSvg.appendChild(textBg);
                this.measurementSvg.appendChild(text);
            }

            undoLastPoint() {
                // **EXPLICAÈšIE DETALIATÄ‚:** È˜tergem ultimul punct adÄƒugat È™i mÄƒsurÄƒtoarea asociatÄƒ
                if (this.points.length === 0) return;
                
                const lastPoint = this.points.pop();
                
                // È˜tergem elementul vizual al punctului
                const pointElement = document.querySelector(`[data-point-id="${lastPoint.id}"]`);
                if (pointElement) {
                    pointElement.remove();
                }
                
                // È˜tergem ultima mÄƒsurÄƒtoare dacÄƒ existÄƒ
                if (this.measurements.length > 0) {
                    const lastMeasurement = this.measurements.pop();
                    
                    // È˜tergem linia de mÄƒsurare din SVG
                    const measurementElements = this.measurementSvg.querySelectorAll(`[data-measurement-id="${lastMeasurement.id}"]`);
                    measurementElements.forEach(el => el.remove());
                }
                
                // **EXPLICAÈšIE:** ActualizÄƒm eticheta urmÄƒtorului punct
                if (this.points.length === 0) {
                    this.nextPointLabel = 'A';
                } else {
                    const lastLabel = this.points[this.points.length - 1].label;
                    this.nextPointLabel = String.fromCharCode(lastLabel.charCodeAt(0) + 1);
                }
                
                this.updatePointsList();
                this.updateMeasurementsList();
                this.updateControls();
                
                this.showToast('Ultimul punct a fost È™ters', 'info');
            }

            closeShape() {
                // **EXPLICAÈšIE DETALIATÄ‚:** Ãnchidem forma geometricÄƒ conectÃ¢nd ultimul punct cu primul
                if (this.points.length < 3) {
                    this.showToast('AveÈ›i nevoie de cel puÈ›in 3 puncte pentru a Ã®nchide forma', 'error');
                    return;
                }
                
                const firstPoint = this.points[0];
                const lastPoint = this.points[this.points.length - 1];
                
                // CalculÄƒm mÄƒsurÄƒtoarea pentru linia de Ã®nchidere
                const pixelDistance = Math.sqrt(
                    Math.pow(firstPoint.x - lastPoint.x, 2) + 
                    Math.pow(firstPoint.y - lastPoint.y, 2)
                );
                
                const mmDistance = (pixelDistance / this.pixelsPerMM) * (this.cameraDistance / 2);
                
                const closingMeasurement = {
                    id: Date.now(),
                    fromPoint: lastPoint.label,
                    toPoint: firstPoint.label,
                    label: `${lastPoint.label}${firstPoint.label}`,
                    pixelDistance: pixelDistance,
                    mmDistance: mmDistance,
                    mDistance: mmDistance / 1000,
                    point1: lastPoint,
                    point2: firstPoint,
                    isClosing: true
                };
                
                this.measurements.push(closingMeasurement);
                this.drawMeasurementLine(closingMeasurement);
                this.updateMeasurementsList();
                
                // CalculÄƒm aria formei dacÄƒ este posibil
                this.calculateShapeArea();
                
                this.showToast(`Forma Ã®nchisÄƒ! Latura ${closingMeasurement.label} adÄƒugatÄƒ.`, 'success');
            }

            calculateShapeArea() {
                // **EXPLICAÈšIE DETALIATÄ‚:** CalculÄƒm aria formei folosind formula shoelace
                if (this.points.length < 3) return;
                
                let area = 0;
                const n = this.points.length;
                
                // **EXPLICAÈšIE:** Formula shoelace pentru calculul ariei unui poligon
                for (let i = 0; i < n; i++) {
                    const j = (i + 1) % n;
                    area += this.points[i].x * this.points[j].y;
                    area -= this.points[j].x * this.points[i].y;
                }
                
                area = Math.abs(area) / 2;
                
                // Convertim aria din pixeli pÄƒtraÈ›i Ã®n metri pÄƒtraÈ›i
                const pixelAreaToMM2 = Math.pow(1 / this.pixelsPerMM, 2);
                const areaMM2 = area * pixelAreaToMM2 * Math.pow(this.cameraDistance / 2, 2);
                const areaM2 = areaMM2 / 1000000;
                
                // AdÄƒugÄƒm aria la lista de mÄƒsurÄƒtori
                const areaInfo = {
                    id: Date.now(),
                    label: 'Aria formei',
                    type: 'area',
                    areaMM2: areaMM2,
                    areaM2: areaM2
                };
                
                this.measurements.push(areaInfo);
                this.updateMeasurementsList();
            }

            clearAllPoints() {
                // **EXPLICAÈšIE DETALIATÄ‚:** È˜tergem toate punctele È™i mÄƒsurÄƒtorile
                
                // È˜tergem toate elementele vizuale ale punctelor
                const pointElements = document.querySelectorAll('.point-marker');
                pointElements.forEach(el => el.remove());
                
                // CurÄƒÈ›Äƒm SVG-ul de toate liniile
                this.measurementSvg.innerHTML = '';
                
                // ResetÄƒm datele
                this.points = [];
                this.measurements = [];
                this.nextPointLabel = 'A';
                
                this.updatePointsList();
                this.updateMeasurementsList();
                this.updateControls();
                
                this.showToast('Toate punctele au fost È™terse', 'info');
            }

            updatePointsList() {
                // **EXPLICAÈšIE:** ActualizÄƒm lista punctelor din panoul lateral
                const pointsList = document.getElementById('points-list');
                
                if (this.points.length === 0) {
                    pointsList.innerHTML = `
                        <div style="text-align: center; color: #6c757d; padding: 20px; font-style: italic;">
                            Nu existÄƒ puncte adÄƒugate
                        </div>
                    `;
                    return;
                }

                pointsList.innerHTML = this.points.map(point => `
                    <div class="point-item">
                        <div>
                            <span class="point-label">Punct ${point.label}</span>
                            <div class="point-coords">X: ${Math.round(point.x)}, Y: ${Math.round(point.y)}</div>
                        </div>
                    </div>
                `).join('');
            }

            updateMeasurementsList() {
                // **EXPLICAÈšIE:** ActualizÄƒm lista mÄƒsurÄƒtorilor din panoul central
                const measurementsList = document.getElementById('measurements-list');
                
                if (this.measurements.length === 0) {
                    measurementsList.innerHTML = `
                        <h4>ğŸ“ MÄƒsurÄƒtori:</h4>
                        <div style="text-align: center; color: #6c757d; padding: 20px; font-style: italic;">
                            Nu existÄƒ mÄƒsurÄƒtori Ã®ncÄƒ
                        </div>
                    `;
                    return;
                }

                const measurementsHTML = this.measurements.map(m => {
                    if (m.type === 'area') {
                        return `
                            <div class="measurement-item">
                                <span class="measurement-label">ğŸ“ ${m.label}</span>
                                <span class="measurement-value">${m.areaM2.toFixed(2)} mÂ²</span>
                            </div>
                        `;
                    } else {
                        let displayValue;
                        if (m.mDistance >= 1) {
                            displayValue = `${m.mDistance.toFixed(2)} m`;
                        } else if (m.mmDistance >= 10) {
                            displayValue = `${(m.mmDistance / 10).toFixed(1)} cm`;
                        } else {
                            displayValue = `${m.mmDistance.toFixed(0)} mm`;
                        }
                        
                        return `
                            <div class="measurement-item">
                                <span class="measurement-label">ğŸ“ Latura ${m.label}</span>
                                <span class="measurement-value">${displayValue}</span>
                            </div>
                        `;
                    }
                }).join('');

                measurementsList.innerHTML = `
                    <h4>ğŸ“ MÄƒsurÄƒtori:</h4>
                    ${measurementsHTML}
                `;
            }

            updateControls() {
                // **EXPLICAÈšIE:** ActualizÄƒm starea butoanelor Ã®n funcÈ›ie de situaÈ›ie
                document.getElementById('undo-point').disabled = this.points.length === 0;
                document.getElementById('close-shape').disabled = this.points.length < 3;
            }

            stopAR() {
                // **EXPLICAÈšIE:** OpreÈ™te camera AR È™i reseteazÄƒ starea
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }

                this.video.srcObject = null;
                this.isARActive = false;
                this.isCalibrated = false;
                
                // ReseteazÄƒ controalele
                document.getElementById('start-ar').disabled = false;
                document.getElementById('stop-ar').disabled = true;
                document.getElementById('calibrate-ar').disabled = true;
                document.getElementById('take-photo').disabled = true;
                
                // Ascunde informaÈ›iile de calibrare
                document.getElementById('calibration-display').style.display = 'none';
                
                this.updateARStatus('Camera AR opritÄƒ.', 'info');
            }

            resizeCanvases() {
                // **EXPLICAÈšIE:** RedimensioneazÄƒ canvas-urile pentru a se potrivi cu video-ul
                if (!this.video.videoWidth || !this.video.videoHeight) return;

                const rect = this.video.getBoundingClientRect();
                
                this.arCanvas.width = rect.width;
                this.arCanvas.height = rect.height;
                
                if (this.measurementCanvas) {
                    const photoContainer = document.getElementById('photo-container');
                    const photoRect = photoContainer.getBoundingClientRect();
                    this.measurementCanvas.width = photoRect.width;
                    this.measurementCanvas.height = photoRect.height;
                }
            }

            // ================== GESTIONARE PROIECTE ==================

            showSaveModal() {
                // **EXPLICAÈšIE:** AfiÈ™eazÄƒ modal-ul pentru salvarea proiectului
                if (this.points.length === 0) {
                    this.showToast('Nu existÄƒ puncte de salvat!', 'error');
                    return;
                }
                
                document.getElementById('save-modal').style.display = 'block';
                document.getElementById('project-name').focus();
            }

            hideSaveModal() {
                // **EXPLICAÈšIE:** Ascunde modal-ul de salvare
                document.getElementById('save-modal').style.display = 'none';
                document.getElementById('project-name').value = '';
                document.getElementById('project-description').value = '';
            }

            saveProject() {
                // **EXPLICAÈšIE DETALIATÄ‚:** SalveazÄƒ proiectul curent cu toate datele
                const name = document.getElementById('project-name').value.trim();
                const description = document.getElementById('project-description').value.trim();
                
                if (!name) {
                    this.showToast('IntroduceÈ›i un nume pentru proiect!', 'error');
                    return;
                }
                
                const project = {
                    id: Date.now(),
                    name: name,
                    description: description,
                    createdAt: new Date().toISOString(),
                    photoData: this.photoData,
                    points: [...this.points],
                    measurements: [...this.measurements],
                    calibration: {
                        pixelsPerMM: this.pixelsPerMM,
                        referenceObject: this.referenceObject,
                        cameraDistance: this.cameraDistance
                    }
                };
                
                this.projects.push(project);
                this.saveProjectsToStorage();
                this.updateProjectsList();
                this.hideSaveModal();
                
                this.showToast(`Proiectul "${name}" a fost salvat!`, 'success');
            }

            loadProject(projectId) {
                // **EXPLICAÈšIE:** ÃncarcÄƒ un proiect salvat
                const project = this.projects.find(p => p.id === projectId);
                if (!project) return;
                
                // CurÄƒÈ›Äƒm starea curentÄƒ
                this.clearAllPoints();
                
                // ÃncÄƒrcÄƒm datele proiectului
                this.photoData = project.photoData;
                this.points = [...project.points];
                this.measurements = [...project.measurements];
                
                if (project.calibration) {
                    this.pixelsPerMM = project.calibration.pixelsPerMM;
                    this.referenceObject = project.calibration.referenceObject;
                    this.cameraDistance = project.calibration.cameraDistance;
                    this.isCalibrated = true;
                }
                
                // AfiÈ™Äƒm fotografia
                if (this.photoData) {
                    this.capturedPhoto.src = this.photoData;
                    this.capturedPhoto.style.display = 'block';
                    this.measurementCanvas.style.display = 'block';
                    this.measurementSvg.style.display = 'block';
                    document.querySelector('.photo-placeholder').style.display = 'none';
                    
                    this.setupMeasurementCanvas();
                    
                    // RedesenÄƒm punctele È™i mÄƒsurÄƒtorile
                    setTimeout(() => {
                        this.redrawProject();
                    }, 100);
                }
                
                this.currentProject = project;
                this.updateProjectsList();
                
                this.showToast(`Proiectul "${project.name}" a fost Ã®ncÄƒrcat!`, 'success');
            }

            redrawProject() {
                // **EXPLICAÈšIE:** RedeseneazÄƒ toate punctele È™i mÄƒsurÄƒtorile unui proiect Ã®ncÄƒrcat
                
                // DesenÄƒm punctele
                this.points.forEach(point => {
                    this.drawPoint(point);
                });
                
                // DesenÄƒm mÄƒsurÄƒtorile
                this.measurements.forEach(measurement => {
                    if (measurement.type !== 'area') {
                        this.drawMeasurementLine(measurement);
                    }
                });
                
                // ActualizÄƒm eticheta urmÄƒtorului punct
                if (this.points.length > 0) {
                    const lastLabel = this.points[this.points.length - 1].label;
                    this.nextPointLabel = String.fromCharCode(lastLabel.charCodeAt(0) + 1);
                } else {
                    this.nextPointLabel = 'A';
                }
                
                this.updatePointsList();
                this.updateMeasurementsList();
                this.updateControls();
            }

            deleteProject(projectId) {
                // **EXPLICAÈšIE:** È˜terge un proiect salvat
                this.projects = this.projects.filter(p => p.id !== projectId);
                this.saveProjectsToStorage();
                this.updateProjectsList();
                
                if (this.currentProject && this.currentProject.id === projectId) {
                    this.currentProject = null;
                }
                
                this.showToast('Proiectul a fost È™ters!', 'info');
            }

            updateProjectsList() {
                // **EXPLICAÈšIE:** ActualizeazÄƒ lista proiectelor salvate
                const projectsList = document.getElementById('projects-list');
                
                if (this.projects.length === 0) {
                    projectsList.innerHTML = `
                        <div style="text-align: center; color: #6c757d; padding: 20px; font-style: italic;">
                            Nu existÄƒ proiecte salvate
                        </div>
                    `;
                    return;
                }

                projectsList.innerHTML = this.projects.map(project => {
                    const date = new Date(project.createdAt).toLocaleDateString('ro-RO');
                    const isActive = this.currentProject && this.currentProject.id === project.id;
                    
                    return `
                        <div class="project-item ${isActive ? 'active' : ''}" onclick="roofCalculator.loadProject(${project.id})">
                            <div class="project-name">${project.name}</div>
                            <div class="project-info">
                                ğŸ“… ${date} | ğŸ“ ${project.points.length} puncte | ğŸ“ ${project.measurements.length} mÄƒsurÄƒtori
                                <br>
                                ${project.description || 'FÄƒrÄƒ descriere'}
                            </div>
                            <button onclick="event.stopPropagation(); roofCalculator.deleteProject(${project.id})" 
                                    style="position: absolute; top: 5px; right: 5px; background: #dc3545; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer;">
                                ğŸ—‘ï¸
                            </button>
                        </div>
                    `;
                }).join('');
            }

            saveProjectsToStorage() {
                // **EXPLICAÈšIE:** SalveazÄƒ proiectele Ã®n localStorage
                try {
                    localStorage.setItem('roofCalculatorProjects', JSON.stringify(this.projects));
                } catch (error) {
                    console.error('Eroare la salvarea proiectelor:', error);
                    this.showToast('Eroare la salvarea proiectelor!', 'error');
                }
            }

            loadProjects() {
                // **EXPLICAÈšIE:** ÃncarcÄƒ proiectele din localStorage
                try {
                    const saved = localStorage.getItem('roofCalculatorProjects');
                    if (saved) {
                        this.projects = JSON.parse(saved);
                        this.updateProjectsList();
                    }
                } catch (error) {
                    console.error('Eroare la Ã®ncÄƒrcarea proiectelor:', error);
                    this.projects = [];
                }
            }

            // ================== EXPORT FUNCÈšII ==================

            exportToPDF() {
                // **EXPLICAÈšIE DETALIATÄ‚:** ExportÄƒ proiectul curent Ã®n format PDF
                if (this.measurements.length === 0) {
                    this.showToast('Nu existÄƒ mÄƒsurÄƒtori de exportat!', 'error');
                    return;
                }

                try {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();
                    
                    // Header
                    doc.setFontSize(20);
                    doc.text('Roof Calculator Pro - Raport MÄƒsurÄƒtori', 20, 20);
                    
                    // InformaÈ›ii proiect
                    doc.setFontSize(12);
                    const projectName = this.currentProject ? this.currentProject.name : 'Proiect Nesalvat';
                    doc.text(`Proiect: ${projectName}`, 20, 35);
                    doc.text(`Data: ${new Date().toLocaleDateString('ro-RO')}`, 20, 45);
                    doc.text(`Calibrare: ${this.referenceObject?.type || 'Nu este calibrat'}`, 20, 55);
                    
                    // MÄƒsurÄƒtori
                    doc.setFontSize(14);
                    doc.text('MÄƒsurÄƒtori:', 20, 75);
                    
                    let y = 90;
                    doc.setFontSize(11);
                    
                    this.measurements.forEach(m => {
                        if (m.type === 'area') {
                            doc.text(`ğŸ“ Aria formei: ${m.areaM2.toFixed(2)} mÂ²`, 25, y);
                        } else {
                            let displayValue;
                            if (m.mDistance >= 1) {
                                displayValue = `${m.mDistance.toFixed(2)} m`;
                            } else if (m.mmDistance >= 10) {
                                displayValue = `${(m.mmDistance / 10).toFixed(1)} cm`;
                            } else {
                                displayValue = `${m.mmDistance.toFixed(0)} mm`;
                            }
                            doc.text(`ğŸ“ Latura ${m.label}: ${displayValue}`, 25, y);
                        }
                        y += 10;
                    });
                    
                    // InformaÈ›ii tehnice
                    y += 20;
                    doc.setFontSize(10);
                    doc.text('InformaÈ›ii tehnice:', 20, y);
                    y += 10;
                    doc.text(`- Scala calibrare: ${this.pixelsPerMM.toFixed(3)} pixeli/mm`, 25, y);
                    y += 8;
                    doc.text(`- DistanÈ›Äƒ camerÄƒ: ${this.cameraDistance.toFixed(1)} m`, 25, y);
                    y += 8;
                    doc.text(`- NumÄƒrul punctelor: ${this.points.length}`, 25, y);
                    
                    // Salvare
                    const fileName = `RoofCalculator_${projectName.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.pdf`;
                    doc.save(fileName);
                    
                    this.showToast('PDF exportat cu succes!', 'success');
                    
                } catch (error) {
                    console.error('Eroare la exportul PDF:', error);
                    this.showToast('Eroare la exportul PDF!', 'error');
                }
            }

            exportToJSON() {
                // **EXPLICAÈšIE DETALIATÄ‚:** ExportÄƒ proiectul Ã®n format JSON
                if (this.points.length === 0) {
                    this.showToast('Nu existÄƒ date de exportat!', 'error');
                    return;
                }

                try {
                    const exportData = {
                        metadata: {
                            exportDate: new Date().toISOString(),
                            version: '1.0',
                            application: 'Roof Calculator Pro AR'
                        },
                        project: {
                            name: this.currentProject?.name || 'Proiect Nesalvat',
                            description: this.currentProject?.description || '',
                            createdAt: this.currentProject?.createdAt || new Date().toISOString()
                        },
                        calibration: {
                            isCalibrated: this.isCalibrated,
                            pixelsPerMM: this.pixelsPerMM,
                            referenceObject: this.referenceObject,
                            cameraDistance: this.cameraDistance
                        },
                        geometry: {
                            points: this.points.map(p => ({
                                label: p.label,
                                coordinates: { x: p.x, y: p.y },
                                id: p.id
                            })),
                            measurements: this.measurements.map(m => {
                                if (m.type === 'area') {
                                    return {
                                        type: 'area',
                                        label: m.label,
                                        value: m.areaM2,
                                        unit: 'mÂ²'
                                    };
                                } else {
                                    return {
                                        type: 'distance',
                                        label: m.label,
                                        fromPoint: m.fromPoint,
                                        toPoint: m.toPoint,
                                        value: m.mDistance,
                                        unit: 'm'
                                    };
                                }
                            })
                        },
                        technical: {
                            deviceOrientation: this.deviceOrientation,
                            photoData: this.photoData ? 'included' : 'not_available'
                        }
                    };

                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    
                    const projectName = exportData.project.name.replace(/[^a-z0-9]/gi, '_');
                    a.href = url;
                    a.download = `RoofCalculator_${projectName}_${new Date().toISOString().split('T')[0]}.json`;
                    a.click();
                    
                    URL.revokeObjectURL(url);
                    
                    this.showToast('JSON exportat cu succes!', 'success');
                    
                } catch (error) {
                    console.error('Eroare la exportul JSON:', error);
                    this.showToast('Eroare la exportul JSON!', 'error');
                }
            }

            // ================== UTILITÄ‚ÈšI ==================

            updateARStatus(message, type = 'info') {
                // **EXPLICAÈšIE:** ActualizeazÄƒ statusul AR din panoul lateral
                const statusElement = document.getElementById('ar-status');
                const icons = {
                    'info': 'â„¹ï¸',
                    'success': 'âœ…',
                    'warning': 'âš ï¸',
                    'error': 'âŒ'
                };

                statusElement.innerHTML = `${icons[type] || 'â„¹ï¸'} ${message}`;
                statusElement.className = `status-info ${type}`;
                
                console.log(`[AR ${type.toUpperCase()}] ${message}`);
            }

            showToast(message, type = 'info') {
                // **EXPLICAÈšIE:** AfiÈ™eazÄƒ notificÄƒri toast Ã®n colÈ›ul ecranului
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = `toast ${type}`;
                toast.classList.add('show');
                
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }
        }

        // IniÈ›ializare aplicaÈ›ie
        let roofCalculator;
        document.addEventListener('DOMContentLoaded', () => {
            roofCalculator = new RoofCalculatorProAR();
        });

        console.log('ğŸš€ ROOF CALCULATOR PRO AR - ÃncÄƒrcat È™i funcÈ›ional!');
        console.log('âœ… Toate modulele AR sunt disponibile È™i funcÈ›ionale');
    </script>
</body>
</html>